# SoftwareEngineeringLab-E7
## سید مهدی فقیه 97106198
## محمدرضا یوسف پور 97106324
## درصد مشارکت هر دو عضو تیم در انجام آزمایش یکسان بوده است

### شرح آزمایش :

متاسفانه نتوانستیم بیش از یک مورد State or Strategy پیدا کنیم و برای اینکه 7 مورد بازآرایی را انجام داده باشیم تعداد بیشتری Self Encapsulated Field و ... را انجام دادیم.

برای بازآرایی Separate query from modifier در کلاس Memory تابع getTemp را که هم وظیفه تغییر lastTempSize و هم بازگرداندن مقدار فعلی آن را بر عهده داشت، به دو تابع جداگانه تبدیل کردیم که هر دو پشت سر هم فراخوانی شوند و به این ترتیب query و modifier از هم جدا شدند

برای بازآرایی State or Strategy  در کلاس GrammarSymbol کلاسی به نام GrammarSymbolType اضافه شد که دو کلاس NonTerminalGrammarSymbol و TerminalGrammarSymbol از آن ارث بری کنند و در نتیجه در کلاس GrammarSymbol تنها یک متغیر از کلاس GrammarSymbolType وجود داشته باشد.

برای بازآرایی Self Encapsulated Field در کلاس Memory برای فیلدهای این کلاس getter و setter تعریف شد و به طور مستقیم از فیلدها برای گرفتن مقدار یا تغییر مقدار آنها استفاده نشد.

برای بازآرایی Self Encapsulated Field در کلاس 3AddressCode فیلدهای این کلاس از public به private تغییر یافتند و getter برای آنها اضافه شد.

برای بازآرایی Self Encapsulated Field در کلاس Action فیلدهای این کلاس از public به private تغییر یافتند و getter برای آنها اضافه شد و چون مقدار آنها در طول برنامه تغییر نمی یافت به صورت final تعریف شدند.

برای بازآرایی Self Encapsulated Method در کلاس CodeGenerator توابعی که از کلاس های دیگر استفاده نمی شدند از public به private تغییر کردند تا از خارج کلاس قابل دسترسی نباشند.

برای بازآرایی Self Encapsulated Field در کلاس Klass فیلدهای این کلاس از public به private تغییر یافتند و setter برای آنها اضافه شد.

## پرسش ها

## سوال اول

### 1- کد تمیز:

یکی از مهم ترین تعاریف کد تمیز این است که بتوانیم به سادگی کد را متوجه شویم و بتوانیم در عین سادگی ان را تغییر دهیم کدنویسی تمیز (Clean Code) مجموعه اصولی است که به شما کمک می‌کند کدی بنویسید، که فهم و اصلاح آن توسط دیگران و یا بعد از مدت‌های طولانی برای خودتان سخت نباشد. این اصول استانداردهایی هستند که اگر رعایت شوند، شما را تبدیل به یک برنامه نویس حرفه ای می‌کنند. کدنویسی تمیز در کار گروهی اهمیت بسیار زیادی دارد.

در متدولوژی هایی مانند چابک (Agile) کدنویسی تمیز ضروری به نظر می‌رسد زیرا اعضای تیم، در بسیاری از موارد ناچار به تکمیل و اصلاح کدهای یکدیگر هستند. کد کثیف (Dirty Code) اصطلاحی است که در برابر کدنویسی تمیز وجود دارد. عدم رعایت اصول کدنویسی تمیز، بی نظمی و استفاده از رویه‌های تکراری کد شما را به Dirty Code تبدیل می‌کند.

### 2-بدهی فنی :

بدهی فنی Technical Debt مفهوم جالبی است که طی چند سال گذشته سرتیتر اصلی رسانه‌ها و مورد توجه مدیران پروژه قرار گرفته است. چرا که به یک موضوع فراگیر در کل اکوسیستم پروژه نرم افزاری تبدیل شده است.

بدهی فنی Technical Debt یک اصطلاح مالی به نظر می‌رسد. وقتی صحبت از توسعه نرم افزار می‌شود، بدهی فنی ایده‌ای است که برخی شرکت‌های توسعه‌دهنده نرم افزار از آن استفاده می‌کنند و برخی کارهای غیر ضروری در طول توسعه یک پروژه نرم افزاری به تاخیر می‌افتد تا به زمان تحویل برسد.

### 3-بوی بد :

وجود بوی بد در کد قطعا به این معنی نیست که نرم افزار کار نمی کند، نرم افزار با وجود بوی بد کد باز هم خروجی خود را می دهد. اما این بوی بد ممکن است باعث کند شدن پردازش، افزایش خطر خرابی و خطاهای نرم افزار شود.
کد بد بو باعث پایین آمدن کیفیت کد و در نتیجه افزایش بدهی فنی می شود. با توجه به استانداردهای طراحی که توسط سازمان ها تعیین می شود، بوی کد در پروژه های مختلف و بین یک توسعه دهنده با توسعه دهنده ی دیگر متفاوت است.

## سوال دوم

### Bloaters :

متد ها و کلاس هایی هستند که به حدی گسترده و بزرگ شده اند که کار با آنها سخت است. معمولا این بوها بلافاصله ایجاد نمی شوند، بلکه با تکامل برنامه و گذشت زمان بوجود می آیند.

مواردی مثل long Methods و large class  و Primitive Obsession می تواند باعث وجود این مشکل شود

### Object-Orientation Abusers :

این بوها مربوط به استفاده ی درست یا نادرست از اصول برنامه نویسی شیء گرا هستند.

از مواردی که باعث این اتفاق می شود می توان به Switch Statements و Temporary Field و Refused Bequest را نام برد

### Change Preventers :

این بو ها به این معنا هستند که اگر نیاز به تغییر بخشی از کد را دارید، باید در بخش های دیگر نیز تغییرات زیادی را ایجاد کنید. در نتیجه توسعه برنامه بسیار پیچیده و پر هزینه خواهد بود.

مواردی مثل Divergent Change و Shotgun Surgery و  Parallel Inheritance Hierarchies از نوع این مورد هستند.

### Dispensables :

چیزی بیهوده و غیر ضروری است که عدم وجود آن در کد باعث تمیزتر شدن، کارآیی و فهم آسان تر کد می شود.

مواردی مثل Comments و Duplicate Code و Lazy Class را می توان برای این مدل نام برد.

### Couplers :

همه ی بو های این گروه به جفت شدن و وابستگی بیش از حد بین کلاس ها اشاره دارد. وابستگی باعث می شود که ایجاد تغییر در یک مکان مستلزم ایجاد انبوهی از تغییرات در مکان های دیگر باشد. 

مواردی مثل Feature Envy و Inappropriate Intimacy و Message Chains و Middle Man را می توان برای این مورد مثال زد

## سوال سوم :

### a :

این بوی بد در دسته ی Dispensable است

### b :

روش های Collapse Hierarchy و inline class


### c :

گاهی اوقات یک کلاس تنبل به منظور ترسیم اهداف توسعه آینده ایجاد می شود، در این مورد، سعی کنید تعادلی بین وضوح و سادگی در کد خود حفظ کنید.

