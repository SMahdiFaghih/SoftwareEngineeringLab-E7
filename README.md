# SoftwareEngineeringLab-E5
## سید مهدی فقیه 97106198
## محمدرضا یوسف پور 97106324
## درصد مشارکت هر دو عضو تیم در انجام آزمایش یکسان بوده است

### شرح آزمایش :

## مورد اول
برای garden، flower،tree کلاس های abstract به شکل enum  ساخته شده استو همچنین interface AbstractGardenCreator با دو تابع createTree و createFlower طبق مثال داده شده ساخته شده اند

دو کلاس irannianGardenCreator و japaneseGardenCreator این interface را implement کرده اند   در  کلاس Garden  هر دوی این creator  ها را داریم که constructor ان با دریافت abstractGarden برای نوع باغ مشحص شده درخت و گل مربوط به آن را بسازد

![image](https://user-images.githubusercontent.com/45511559/206518895-2a13f496-ab5f-4359-b314-3dcc35b1e7a3.png)


## مورد دوم

در ابتدا در کلاس students یک لیستی از دانش آموزان داریم که تمام اهمیت این گزارش مربوط به فایل تست آن است که آن هم به این صورت است که در ابتدا یک instance  از این کلاس را می سازیمکه برای این نمونه تابع loadData
را صدا میزنیم و این تابع 4 دانش آموز را به لیست این نمونه اضافه می کند. سپس دو نمونه ی دیگری را از این کلاس با استفاده از کلاس اولیه ی ساخته شده clone  می کنیم.
سپس برای هر دو نمونه  ی ساخته شده لیست دانش آموزانش را می گیریم و به یکی از آن ها یک دانش آموز اضافه و از دیرگی یک دانش آموز کم میکنیم و سپس تست ها را پاس می کنیم تا نتایج زیر حاصل شود



![image](https://user-images.githubusercontent.com/45511559/206521700-e26ad828-9fe6-4a1a-84c1-cf6b0b3f2c71.png)


## مورد سوم

توضیح این نمونه به این صورت است که ما در ابتدا یک کلاس کامپیوتر داریم که یک فیلد HDD دارد که در این روش طراحی باید computerBuilder یک کامپیوتر با مشخصاتی که ما می دهیم بسازیم. این کلاس Builder یک کامپیوتر جدید با مشخصات داده شده می 
سازد. تست این مورد به این صورت است که بعد از ساختن یک کامپیوتر جدید مقدار فیلد HDD کامپیوتر ساخته شده را با مقدار مورد انتظار مقایسه می کند.


![image](https://user-images.githubusercontent.com/45511559/206523001-25e8eee3-357c-49f8-8f16-863a3e1dd24c.png)


### پرسش ها :

1- الگوهای Creational: این الگوها با مقداردهی اولیه و پیکربندی کلاس ها و اشیاء سر و کار دارند و بیان می کنند که چگونه باید کلاس ها ساخته شوند.

الگوهای Structural: با نحوه decoupling interface ها و نحوه پیاده سازی کلاس ها و اشیا و ارتباط بین کلاس های مختلف با یکدیگر می پردازند 

الگوهای Behavioral: با نحوه برقراری ارتباط بین کلاس ها برای رد و بدل کردن اطلاعات و فراخوانی یک دیگر سر و کار دارند.

2- هر سه الگوی استفاده شده Creational هستند

3- الگوهای طراحی اصول انتزاعی اصلی هستند که قرار است در هنگام طراحی نرم افزار از آنها پیروی کنیم. آنها را می توان به هر زبانی، بر روی هر پلتفرمی صرف نظر از وضعیتی که در شرایط مجاز قرار داریم، اعمال کرد. اصول SOLID راه حل هایی برای مشکلات دنیای واقعی هستند که بارها و بارها ظاهر می شوند، بنابراین به جای اختراع مجدد چرخ، از الگوهای طراحی پیروی می کنیم که به خوبی اثبات شده است، توسط دیگران آزمایش شده است و پیروی از آنها بی خطر است. اکنون، الگوهای طراحی خاص هستند. فقط شرایط و ضوابطی وجود دارد که در آنها می توان یک الگوی طراحی را اعمال کرد.

4- دو اصل Open/Closed principle و Single Responsibility با استفاده از الگوی Singleton نقض می شوند. 
زیرا برای Open بودن یک کلاس باید بتوان از آن ارث بری کرد در حالیکه اگر این اتفاق برای یک کلاس Singleton بیفتد در نتیجه دو instance از آن وجود خواهد داشت و دیگر singleton نیست پس این اصل از اصول SOLID باالگوی Singleton در تضاد است.

می توان گفت که الگوی Singleton اصل Single Responsibility را نیز نقض می کند زیرا کلاس Singleton علاوه بر وظیفه اصلی خود، وظیفه جلوگیری از ساخته شدن نمونه دیگری از این کلاس و در واقع singleton بودن آن را نیز با کنترل constructor خود بر عهده دارد. 
